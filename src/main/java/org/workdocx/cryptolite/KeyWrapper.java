package org.workdocx.cryptolite;

import java.security.InvalidKeyException;
import java.security.Key;
import java.security.KeyFactory;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.X509EncodedKeySpec;

import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;

/**
 * This class provides secure "wrapping" of keys. Wrapping a key is important if you need to store
 * it in, for example, a database. It is not safe to store a raw key as this could be compromised,
 * so you need to wrap a key before storing it.
 * <p>
 * The wrapping process encrypts the key, so that it can be safely stored. Great! However the
 * wrapping encryption process requires a further key! The question therefore arises - how does one
 * safely store the wrapping key?
 * <p>
 * The answer is to use a "password-based key derivation function" (PBKDF for short). This provides
 * a way to generate the same key repeatedly, from a password (or some other secret string).
 * <p>
 * There is one last problem to be overcome, which is that if two people use identical passwords,
 * the generated keys will be identical. This could perhaps give away someone's password. The answer
 * is therefore to use a "salt value" (which can be generated by calling
 * {@link Random#generateSalt()}). The salt adds randomness to the process so that two people using
 * the same password will still get different keys.
 * <p>
 * This does means you'll need to store the salt value for each person and use it each time in order
 * to ensure you can regenerate the key. This is considered acceptable as the salt is not a
 * particularly sensitive value - all it does is add a little randomness.
 * <p>
 * The cryptographic algorithms used in this class are those indicated in the
 * "Beginning Cryptography with Java" book. See:
 * http://p2p.wrox.com/book-beginning-cryptography-java/67710-wrapping-rsa-keys.html
 * 
 * @author David Carboni
 * 
 */
public class KeyWrapper {

	/** The algorithm for the wrapping key: {@value #WRAP_KEY_ALGORITHM}. */
	private static final String WRAP_KEY_ALGORITHM = "AES";

	/** The algorithm to use for wrapping secret keys: {@value #WRAP_ALGORITHM_SYMMETRIC}. */
	private static final String WRAP_ALGORITHM_SYMMETRIC = "AESWrap";

	/** The algorithm to use for wrapping private keys: {@value #WRAP_ALGORITHM_ASYMMETRIC}. */
	private static final String WRAP_ALGORITHM_ASYMMETRIC = "AES/ECB/PKCS7Padding";

	/** The key size for the wrapping key: {@value #WRAP_KEY_SIZE}. */
	private static final int WRAP_KEY_SIZE = 128;

	/**
	 * The algorithm to use for password-based key derivation, which is used to generate the
	 * wrapping key: {@value #PBKD_ALGORITHM}.
	 */
	private static final String PBKD_ALGORITHM = "PBKDF2WithHmacSHA1";

	/**
	 * The number of iterations to perform when doing the password-based key derivation to generate
	 * the wrapping key: {@value #PBKD_ITERATIONS}.
	 */
	public static final int PBKD_ITERATIONS = 1024;

	private SecretKey wrapKey;

	/**
	 * This is the constructor you should typically use. It initialises the instance with a wrap key
	 * based on the given password and salt values.
	 * 
	 * @param password
	 *            The password to use as the basis for wrapping keys.
	 * @param salt
	 *            A value for this can be obtained from {@link Random#generateSalt()}. You need to
	 *            store a salt value for each password and ensure the matching one is passed in each
	 *            time this constructor is invoked.
	 */
	public KeyWrapper(String password, String salt) {

		wrapKey = generateKey(password, salt);
	}

	/**
	 * This constructor should only be used if you have a secure way of storing the wrap key and
	 * cannot generate it from a password and salt value.
	 * <p>
	 * This sets the given wrap key directly, rather than generating it.
	 * 
	 * @param wrapKey
	 *            The wrap key, base64-encoded, as returned by {@link #getWrapKey()}.
	 */
	public KeyWrapper(String wrapKey) {

		setWrapKey(wrapKey);
	}

	/**
	 * Wraps the given {@link SecretKey} using {@value #WRAP_ALGORITHM_SYMMETRIC}.
	 * 
	 * @param key
	 *            The {@link SecretKey} to be wrapped. This method internally just calls
	 *            {@link #wrap(Key)}, but this provides a clear naming match with
	 *            {@link #unwrapSecretKey(String)}.
	 * @return A String representation (base64-encoded) of the wrapped {@link SecretKey}, for ease
	 *         of storage.
	 */
	public String wrapSecretKey(SecretKey key) {
		return wrap(key, WRAP_ALGORITHM_SYMMETRIC);
	}

	/**
	 * Wraps the given {@link SecretKey} using {@value #WRAP_ALGORITHM_ASYMMETRIC}.
	 * 
	 * @param key
	 *            The {@link PrivateKey} to be wrapped. This method internally just calls
	 *            {@link #wrap(Key)}, but this provides a clear naming match with
	 *            {@link #unwrapPrivateKey(String)}.
	 * @return A String representation (base64-encoded) of the wrapped {@link PrivateKey}, for ease
	 *         of storage.
	 */
	public String wrapPrivateKey(PrivateKey key) {

		return wrap(key, WRAP_ALGORITHM_ASYMMETRIC);
	}

	/**
	 * Encodes the given {@link PublicKey} <em>without wrapping</em>. Since a public key is public,
	 * this is a convenience method provided to convert it to a String for unprotected storage.
	 * <p>
	 * This method internally calls {@link Codec#toBase64String(byte[])}, passing the value of
	 * {@link PublicKey#getEncoded()}.
	 * 
	 * @param key
	 *            The {@link PublicKey} to be encoded.
	 * @return A String representation (base64-encoded) of the raw {@link PublicKey}, for ease of
	 *         storage.
	 */
	public String encodePublicKey(PublicKey key) {
		byte[] bytes = key.getEncoded();
		return Codec.toBase64String(bytes);
	}

	/**
	 * Unwraps the given encoded {@link SecretKey}, using WRAP_ALGORITHM_SYMMETRIC.
	 * 
	 * @param wrappedKey
	 *            The wrapped key, base-64 encoded, as returned by {@link #wrapSecretKey(SecretKey)}
	 *            .
	 * @return The unwrapped {@link SecretKey}.
	 */
	public SecretKey unwrapSecretKey(String wrappedKey) {

		return (SecretKey) unwrap(wrappedKey, Keys.SYMMETRIC_ALGORITHM, Cipher.SECRET_KEY, WRAP_ALGORITHM_SYMMETRIC);
	}

	/**
	 * Unwraps the given encoded {@link PrivateKey}, using WRAP_ALGORITHM_ASYMMETRIC.
	 * 
	 * @param wrappedKey
	 *            The wrapped key, base-64 encoded, as returned by
	 *            {@link #wrapPrivateKey(PrivateKey)} .
	 * @return The unwrapped {@link PrivateKey}.
	 */
	public PrivateKey unwrapPrivateKey(String wrappedKey) {

		return (PrivateKey) unwrap(wrappedKey, Keys.ASYMMETRIC_ALGORITHM, Cipher.PRIVATE_KEY, WRAP_ALGORITHM_ASYMMETRIC);
	}

	/**
	 * Decodes the given encoded {@link PublicKey}.
	 * <p>
	 * See: http://stackoverflow.com/questions/2411096/how-to-recover-a-rsa-public-key-from-a-byte-
	 * array
	 * 
	 * @param encodedKey
	 *            The public key, base-64 encoded, as returned by
	 *            {@link #encodePublicKey(PublicKey)} .
	 * @return The unwrapped {@link PublicKey}.
	 */
	public PublicKey decodePublicKey(String encodedKey) {

		byte[] bytes = Codec.fromBase64String(encodedKey);
		KeyFactory keyFactory;
		try {
			keyFactory = KeyFactory.getInstance(Keys.ASYMMETRIC_ALGORITHM, SecurityProvider.getProviderName());
		} catch (NoSuchAlgorithmException e) {
			throw new RuntimeException("Unable to locate algorithm " + Keys.SYMMETRIC_ALGORITHM, e);
		} catch (NoSuchProviderException e) {
			throw new RuntimeException("Unable to locate JCE provider. Are the BouncyCastle libraries installed?", e);
		}
		try {
			return keyFactory.generatePublic(new X509EncodedKeySpec(bytes));
		} catch (InvalidKeySpecException e) {
			throw new RuntimeException("Unable to convert key '" + encodedKey + "' to a valid public key.", e);
		}
	}

	/**
	 * @return the raw wrapKey bytes, as returned by {@link SecretKey#getEncoded()} as a
	 *         base64-encoded String. This is only useful if you want to store the key, rather than
	 *         regenerate it from a password and salt.
	 */
	public String getWrapKey() {
		return Codec.toBase64String(wrapKey.getEncoded());
	}

	/**
	 * @param wrapKey
	 *            the base64-encoded wrapKey to set. This value can be obtained from
	 *            {@link #getWrapKey()} and {@link #generateWrapKey(String, String)}. This is only
	 *            useful if you want to initialise an instance with a previously stored key, rather
	 *            than recomputing a key from a password and salt.
	 */
	public void setWrapKey(String wrapKey) {
		byte[] wrapKeyBytes = Codec.fromBase64String(wrapKey);
		this.wrapKey = new SecretKeySpec(wrapKeyBytes, WRAP_KEY_ALGORITHM);
	}

	/**
	 * This method generates a new key for the {@value #WRAP_KEY_ALGORITHM} algorithm, with a key
	 * size of {@value #WRAP_KEY_SIZE}. This method uses Password-Based Key Derivation - that is,
	 * for the same starting password and salt value, it will always produce the same key. This
	 * avoids the question of how to securely store a key-wrapping key.
	 * 
	 * @param password
	 *            The starting point to use in generating the key. This can be a password, or any
	 *            suitably secret string. It's worth noting that, if a user's plaintext password is
	 *            used, this makes key derivation secure, but means the key can never be recovered
	 *            if a user forgets their password. If a different value, such as a password hash is
	 *            used, this is not really secure, but does mean the key can be recovered if a user
	 *            forgets their password. It's a trade-off, right?
	 * @param salt
	 *            A value for this parameter can be generated by calling
	 *            {@link Random#generateSalt()}. You'll need to store the salt value (this is ok to
	 *            do because salt isn't particularly sensitive) and use the same salt each time in
	 *            order to always generate the right key. Using salt is good practice as it ensures
	 *            that keys generated from the same token will be different - i.e. if two users use
	 *            the password "password", having a salt value avoids the generated keys being
	 *            identical which, for example, might give away someone's password.
	 * @return A new key-wrapping key, based on the given password, as a base64-encoded String. This
	 *         value is suitable for passing to {@link #setWrapKey(String)}.
	 */
	private SecretKey generateKey(String password, String salt) {

		byte[] saltBytes = Codec.fromBase64String(salt);
		PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray(), saltBytes, PBKD_ITERATIONS, WRAP_KEY_SIZE);
		SecretKeyFactory factory;
		try {
			// TODO: BouncyCastle only provides this PBKDF2 in their JDK 1.6 releases, so try to use it, if available:
			factory = SecretKeyFactory.getInstance(PBKD_ALGORITHM, SecurityProvider.getProviderName());
		} catch (NoSuchAlgorithmException e) {
			try {
				// TODO: If PBKDF2 is not available from BouncyCastle, try to use a default provider (Sun provides PBKDF2 in JDK 1.5):
				factory = SecretKeyFactory.getInstance(PBKD_ALGORITHM);
			} catch (NoSuchAlgorithmException e1) {
				throw new RuntimeException("Unable to locate algorithm " + PBKD_ALGORITHM, e1);
			}
		} catch (NoSuchProviderException e) {
			throw new RuntimeException("Unable to locate JCE provider. Are the BouncyCastle libraries installed?", e);
		}
		Key key;
		try {
			key = factory.generateSecret(pbeKeySpec);
		} catch (InvalidKeySpecException e) {
			throw new RuntimeException("Error generating password-based key.", e);
		}

		// NB: key.getAlgorithm() returns PBKDF_ALGORITHM, rather than WRAP_KEY_ALGORITHM 
		// but if the result of getEncoded() is used to generate a new WRAP_KEY_ALGORITHM Key, 
		// the WRAP_KEY_ALGORITHM key returns the same value for getEncoded().
		// It is therefore safe to do this:
		SecretKey wrapKey = new SecretKeySpec(key.getEncoded(), WRAP_KEY_ALGORITHM);

		return wrapKey;

		// If you're curious about the above comment, try the following to confirm it:
//		System.out.println("PBEKey  algorithm: " + key.getAlgorithm());
//		System.out.println("wrapKey algorithm: " + wrapKey.getAlgorithm());
//		System.out.println("PBEKey  encoded: " + Codec.toBase64String(key.getEncoded()));
//		System.out.println("wrapKey encoded: " + Codec.toBase64String(wrapKey.getEncoded()));
	}

	/**
	 * Wraps the given {@link Key} using the given wrap algorithm.
	 * 
	 * @param key
	 *            The {@link Key} to be wrapped. This can be a secret (symmetric) key or a private
	 *            (asymmetric) key.
	 * @param wrapAlgorithm
	 *            The algorithm to use to wrap the key. This has to be different for a
	 *            {@link SecretKey} than for a {@link PrivateKey}.
	 * @return A String representation (base64-encoded) of the wrapped {@link Key}.
	 */
	private String wrap(Key key, String wrapAlgorithm) {

		try {

			Cipher cipher = Cipher.getInstance(wrapAlgorithm, SecurityProvider.getProviderName());
			cipher.init(Cipher.WRAP_MODE, wrapKey, Random.getInstance());
			byte[] wrappedKey = cipher.wrap(key);
			return Codec.toBase64String(wrappedKey);

		} catch (NoSuchAlgorithmException e) {
			throw new RuntimeException("Could not locate algorithm " + wrapAlgorithm, e);
		} catch (NoSuchProviderException e) {
			throw new RuntimeException("Could not locate provider. Are the BouncyCastle libraries installed?", e);
		} catch (NoSuchPaddingException e) {
			throw new RuntimeException("Error setting up padding for AESWrap", e);
		} catch (InvalidKeyException e) {
			throw new RuntimeException("Error in key for algorithm " + wrapAlgorithm, e);
		} catch (IllegalBlockSizeException e) {
			throw new RuntimeException("Error in block size for algorithm " + wrapAlgorithm, e);
		}
	}

	/**
	 * Unwraps the given encoded {@link PrivateKey}.
	 * 
	 * @param wrappedKey
	 *            The wrapped key, base-64 encoded, as returned by
	 *            {@link #wrapPrivateKey(PrivateKey)} .
	 * @param keyAlgorithm
	 *            The algorithm that the reconstituted key will be for.
	 * @param keyType
	 *            The type of key. This should be a constant from the {@link Cipher} class.
	 * @param wrapAlgorithm
	 *            The algorithm to use to unwrap the key. This has to be different for a
	 *            {@link SecretKey} than for a {@link PrivateKey}.
	 * @return The unwrapped {@link PrivateKey}.
	 */
	private Key unwrap(String wrappedKey, String keyAlgorithm, int keyType, String wrapAlgorithm) {

		try {
			byte[] wrapped = Codec.fromBase64String(wrappedKey);
			Cipher cipher = Cipher.getInstance(wrapAlgorithm, SecurityProvider.getProviderName());
			cipher.init(Cipher.UNWRAP_MODE, wrapKey, Random.getInstance());
			Key result = cipher.unwrap(wrapped, keyAlgorithm, keyType);
			return result;

		} catch (NoSuchAlgorithmException e) {
			throw new RuntimeException("Could not locate algorithm algorithm " + wrapAlgorithm, e);
		} catch (NoSuchProviderException e) {
			throw new RuntimeException("Could not locate JCE provider. Are the BouncyCastle libraries installed?", e);
		} catch (NoSuchPaddingException e) {
			throw new RuntimeException("Error setting up padding for algorithm " + wrapAlgorithm, e);
		} catch (InvalidKeyException e) {
			throw new RuntimeException("Invalid key for algorithm " + wrapAlgorithm, e);
		}
	}

}
